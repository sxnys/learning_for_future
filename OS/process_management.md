# 进程管理
*[摘自 github CS-Notes - 计算机操作系统](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md "github CS-Notes - 计算机操作系统")*

----------

## 一、进程与线程
### 1. 进程
**进程**：**资源分配**的基本单位     
**进程控制块**：**PCB** (Process Control Block)，描述进程的基本信息和运行状态。创建进程、撤销进程实际上就是对 PCB 的操作。    

<div align="center"> <img src="https://raw.githubusercontent.com/CyC2018/CS-Notes/master/docs/notes/pics/a6ac2b08-3861-4e85-baa8-382287bfee9f.png"/></div> 

上图是 4 个程序创建的 4 个进程，可以并发执行（时序图中可以看出不是并行，而是异步交替执行）

### 2. 线程
**线程**：**独立调度**的基本单位     
一个进程可以有多个线程，线程**共享进程资源**    
**e.g.** 浏览器进程里面有很多线程，包括 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

<div align="center"> <img src="https://raw.githubusercontent.com/CyC2018/CS-Notes/master/docs/notes/pics/3cd630ea-017c-488d-ad1d-732b4efeddf5.png"/></div> 

<div align="center">进程中的线程</div>

### 3. 区别
**（1）资源**
**进程** - 资源分配的基本单位    
**线程** - 不拥有资源，但可以访问隶属进程的资源   

**（2）调度**  
**线程** 独立调度的基本单位    
同一进程中，线程切换不会引起进程切换；
不同进程间，线程切换会引起进程切换。

**（3）系统开销**
**进程** - **创建**（分配资源）、**撤销**（回收资源）、**切换**（当前进程CPU环境保存、新调度进程CPU环境设置）开销很大
**线程** - 只保存和设置少量寄存器内容，开销极小

**（4）通信**
**进程通信** - 需要借助 IPC (Inter-Process Communication)
**线程通信** - 读写同一进程中的数据

----------

## 二、进程状态切换
1、三个基本状态
- **就绪状态（ready）**：等待被调度（获取CPU时间）
- **运行状态（running）**
- **阻塞状态（waiting）**：等待资源（不包括CPU时间）

2、状态切换
> 只有**就绪态**和**运行态**可以相互切换，其他的都是单向切换     

<div align="center"> <img src="https://raw.githubusercontent.com/CyC2018/CS-Notes/master/docs/notes/pics/ProcessState.png"/></div> 

`ready --> running` ：进程通过调度算法获得CPU时间         
`running --> ready` ：分配的CPU时间片用完，等待下一次调度    
`running --> waiting` ：缺少需要的资源（不包括CPU时间）

----------

## 三、进程调度算法
*不同环境的调度算法目标不同*      

**1、批处理系统**      
批处理系统没有太多的用户操作，调度算法目标是**保证吞吐量和周转时间**（从提交到终止的时间）
- **先来先服务（First Come First Served, FCFS）**：按照请求的顺序进行调度
**有利于长作业，但不利于短作业**，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

- **短作业优先（Shortest Job First, SJF）**：按估计运行时间最短的顺序进行调度
**有利于短作业，但不利于长作业**。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

- **最短剩余时间优先（Shortest Remaining Time Next, SRTN）**：按估计剩余时间最短的顺序进行调度

**2、交互式系统**         
交互式系统有大量的用户交互操作，在该系统中调度算法的目标是**快速地进行响应**
- **时间片轮转**
将所有就绪进程按 **FCFS 的原则** 排成一个队列，每次调度时把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。
> 时间片轮转算法的效率和时间片的大小有很大关系：
> - 时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。因为进程切换都要保存进程的信息并且载入新进程的信息，这需要花费不少时间。
> - 时间片过长，那么实时性就不能得到保证。

- **优先级调度**
为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

- **多级反馈队列**
为需要连续执行多个时间片的进程设置多个队列，每个队列时间片大小都不同，进程在第一个队列没执行完，就会被移到下一个队列。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程，所以后进的作业不一定慢完成。可以看成是时间片轮转调度算法和优先级调度算法的结合。

<div align="center"> <img src="https://raw.githubusercontent.com/CyC2018/CS-Notes/master/docs/notes/pics/042cf928-3c8e-4815-ae9c-f2780202c68f.png"/></div> 

**3、实时系统**         
实时系统要求一个请求在一个确定时间内得到响应               
硬实时必须满足绝对的截止时间              
软实时可以容忍一定的超时               

----------

## 四、进程同步
1、几个概念
- **临界区**：对临界资源进行访问的那段代码。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。                  
- **同步**：多个进程按一定顺序执行。              
- **互斥**：多个进程在同一时刻只有一个进程能够进入临界区。                
- **信号量**：一个整型变量，可以对其执行 down 和 up 操作，即 P 和 V 操作。down 和 up 操作需要被设计成原语，不可分割，通常是在执行这些操作的时候屏蔽中断。如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量**（Mutex），0 表示临界区已经加锁，1 表示临界区解锁。         
- **down 操作**：信号量大于0，执行 -1；信号量等于0，进入睡眠，等待信号量大于0。                 
- **up 操作**：对信号量执行 +1，唤醒睡眠的进程让其进行 down 操作。                  
- **管程**：引入了 **条件变量** 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。**在一个时刻只能有一个进程使用管程**。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

2、经典同步问题
- 生产者-消费者问题              
- 读者-写者问题                 
- 哲学家进餐问题                

----------

## 五、进程通信
> **进程同步**：控制多个进程按一定顺序执行；一种目的          
> **进程通信**：进程间传输信息；一种手段         
> 为了达到进程同步的目的，需要让进程进行通信，传输进程同步需要的信息。          

### 进程通信的几种方式：
**1、管道**

- 只支持半双工通信（单向交替传输）               
- 只能在父子进程中使用                     

<div align="center"> <img src="https://raw.githubusercontent.com/CyC2018/CS-Notes/master/docs/notes/pics/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"/></div> 
<div align="center">管道通信，fd[0]用于读，fd[1]用于写</div>

**2、FIFO**

- 也称为**命名管道**，去除了管道只能在父子进程中使用的限制。                
- FIFO 常用于 C-S 应用程序中，FIFO 用作汇聚点，在 CS 之间传递数据。                  

<div align="center"> <img src="https://raw.githubusercontent.com/CyC2018/CS-Notes/master/docs/notes/pics/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"/></div> 

**3、消息队列**
相比于FIFO：               

- 消息队列可以**独立于读写进程存在**，避免了FIFO中同步管道的开关时产生的困难；                
- **避免了FIFO的同步阻塞问题**，不需要进程自己提供同步方法                
- 读进程可以根据信息类型**有选择地接收消息**，不像FIFO只能默认接收。                     

**4、信号量**
一个计数器，用于为多个进程提供对共享数据对象的访问。                 

**5、共享存储**
- 允许多个进程**共享一个给定的存储区**。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。                  
- 需要**使用信号量**用来同步对共享存储的访问。                      
- 多个进程可以**将同一个文件映射到它们的地址空间**从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段。                 

**6、套接字**
与其它通信机制不同，它可用于不同机器间的进程通信。

----------

## 六、死锁

> **死锁：** 两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。（进程抢资源谁也不让谁）                              
>
> 一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件。

死锁产生必要条件：                      

1. **互斥：** 每个资源要么已经分配给一个进程，要么可用       
2. **占有和等待：** 已经占有某个资源的进程可以再请求新的进程
3. **不可抢占：** 已经分配给一个进程的资源不能被强制性地抢占，只能有占有它的进程显式释放
4. **环路等待：** 两个或两个以上进程组成一条环路，每个进程都在等待下一个进程释放资源

处理死锁的方法：                    

1. **鸵鸟策略：** 不采取任何措施，忽略死锁（死锁影响不大，发生概率低）
2. **死锁检测和死锁恢复：** 不试图阻止死锁，当检测到死锁发生采取措施恢复                    
   - 每种类型一个资源的死锁检测：通过检测资源分配图（有向图）是否存在环           
   - 每种类型多个资源的死锁检测：（多个资源的银行家算法类似）标记可以请求完剩余资源的进程，进程任务完成释放资源，重复过程直到最后没有进程可以标记，最终剩下的没有被标记的进程都是死锁进程。                
   - 死锁恢复                
     - 利用抢占恢复                
     - 利用回滚恢复                  
     - 杀死进程恢复                
3. **死锁预防：** 在程序运行之前预防死锁
   - 破坏**互斥**条件                   
   - 破坏**占有和等待**条件                 
   - 破环**不可抢占**条件                  
   - 破坏**环路**条件                
4. **死锁避免：** 在程序运行时避免发生死锁（安全状态：若没有死锁发生，任何进程突然请求对资源的最大需求，仍然存在合适的调度次序使得所有进程运行完毕）
   - 单个资源的银行家算法：判断进程对某一种资源的请求是否会进入不安全状态                     
   - 多个资源的银行家算法：判断进程对多种资源的请求是否会进入不安全状态（将多种资源的可用量用向量表示，接下来就和单个资源类似）                      